# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ProsailPlugin
                                 A QGIS plugin
 Plugin to see prosail behavior
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-06-03
        git sha              : $Format:%H$
        copyright            : (C) 2021 by CESBIO
        email                : ludox09@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QObject,Qt,QDate
from qgis.PyQt.QtGui import QIcon,QColor
from qgis.PyQt.QtWidgets import QAction, QGraphicsScene, QTableWidgetItem, QCheckBox
from qgis.core import QgsProject,QgsGeometry,QgsPointXY
from qgis.gui import QgsMapCanvas,QgsMapTool,QgsMapToolEmitPoint,QgsMapToolIdentify,QgsVertexMarker

import time
import glob 
import numpy as np 
import datetime 
import matplotlib.pyplot as plt 
from math import floor
#from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas 
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas 
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar 
import prosail
from xml.dom import minidom
from .resources import *

# Import the code for the DockWidget
from .prosail_plugin_dockwidget import ProsailPluginDockWidget
import os.path

used = [1,2,3,4,5,6,7,8,11,12]
quantile = 1.0

class ProsailPlugin:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ProsailPlugin_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Prosail Plugin')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'ProsailPlugin')
        self.toolbar.setObjectName(u'ProsailPlugin')

        #print "** INITIALIZING ProsailPlugin"

        self.pluginIsActive = False
        self.dockwidget = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ProsailPlugin', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/prosail_plugin/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING ProsailPlugin"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD ProsailPlugin"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Prosail Plugin'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    def combo_change(self):
        self.update_dist_plot()
        #param = self.dockwidget.combo_param.currentText()
        #self.dockwidget.Slider_param_mean.setRange(self.param_range[param][0], self.param_range[param][1])
        #self.dockwidget.Slider_param_mean.setValue(self.param_current[param])
        #print(self.dockwidget.datemin.date(),self.dockwidget.datemax.date())
        #self.Update_Graph()

    def calc_prosail(self,inparam,angles):

        zenith_sun  = angles["solar_zen"]
        azimuth_sun = angles["solar_azi"]
        zenith_obs  = angles["obs_zen"]
        azimuth_obs = angles["obs_azi"]
        
        lai = inparam[0]          # "lai"
        lidfa = inparam[1]      # "lidfa"
        cm = inparam[2]            # "cm" 
        cab = inparam[3]          # "cab"
        n = inparam[4]              # "n"
        car = inparam[5]          # "car"
        psoil = inparam[6]      # "psoil"
        scaled_soil = self.scaled_soil_dic[int(inparam[7])] #"soil type"
        tts = zenith_sun
        tto = zenith_obs
        psi = np.mod(azimuth_sun-azimuth_obs,360)
        cw  = 0.01
        cbrown = 0.5
        hspot = 0.1
       


        rsot = prosail.run_prosail(n,cab,car,cbrown,cw, cm, lai, lidfa, hspot, tts, tto, psi,
                                         ant=0.0, alpha=40.0, typelidf=2,
                                         factor='SDR', psoil=psoil,
                                         soil_spectrum1=scaled_soil, lidfb =1,rsoil =1)

        return rsot

    def likelyhood_SAFY_new_nan(self,init_loglikelyhood,Var_sim,Var_obs,Var_obsstd):
        """
         Computes likelyhood for a set of observation for all enties of the LUT dims= [lut entries, observations, dates]
         New Version small and fast
        """
        # Ignore SWIR
        #Var_sim = np.random.rand(N_LUT,N_DATES) # OK
        #Var_obs = np.random.rand(N_OBS,N_DATES) # OK
        #Var_obsstd = np.random.rand(N_OBS,N_DATES) # OK

        # Threshold uncertainties
        #Var_obsstd = np.clip(Var_obsstd,0.1,100.0)
        #Var_sim = np.clip(Var_sim,0.2,100.0) #e dge effect

        Var_sim = np.ma.masked_array(Var_sim, mask=np.isnan(Var_sim))
        Var_obs = np.ma.masked_array(Var_obs, mask=np.isnan(Var_obs))
        Var_obsstd = np.ma.masked_array(Var_obsstd, mask=np.isnan(Var_obsstd))

        Inverse_obsstd2 = 1.0/(Var_obsstd**2)
        Inverse_obsstd2 = np.ma.masked_array(Inverse_obsstd2, mask=np.isnan(Inverse_obsstd2)) 

        l5 = np.sum(np.log(2*np.pi*Var_obsstd**2) + ((Var_obs**2)*Inverse_obsstd2),axis=1)[np.newaxis,:]# l5 = l1-l3
        l6 =  ((Var_sim**2).dot(Inverse_obsstd2.T)) - (2.0*Var_sim.dot((Var_obs*Inverse_obsstd2).T))
        L = -(l5 + l6)/2.0
        L = L - np.nanmax(L,axis=0)
        loglikelyhood=init_loglikelyhood[:,:] + L
        likelyhood = np.exp(loglikelyhood)
        return(likelyhood)

    def update_table(self):
        self.dockwidget.tableParam.setRowCount(len(self.param_range.keys())) 
        self.dockwidget.tableParam.setColumnCount(5) 
        self.dockwidget.tableParam.setVerticalHeaderLabels([u'Param']) 
        self.dockwidget.tableParam.setHorizontalHeaderLabels([u'Min', u'Center',u'Max',u'Posterior',u'Fixed']) 
        row_name = [k for k in self.param_range.keys()] 

        for i,k in enumerate(self.param_range.copy().keys()): 
            #insert the data in the table 
            label1 = QTableWidgetItem() 
            label2 = QTableWidgetItem() 
            label3 = QTableWidgetItem() 
            label4 = QTableWidgetItem() 
            check  = QTableWidgetItem()

            self.dockwidget.tableParam.setColumnWidth(0, 60)
            self.dockwidget.tableParam.setColumnWidth(1, 60)
            self.dockwidget.tableParam.setColumnWidth(2, 60)
            self.dockwidget.tableParam.setColumnWidth(3, 90)
            self.dockwidget.tableParam.setColumnWidth(4, 30)

            label1.setText(str(self.param_range[k][0])) 
            label1.setTextAlignment(Qt.AlignCenter) 
            self.dockwidget.tableParam.setItem(i,0,label1)

            label2.setText(str(self.param_current[k][0])) 
            label2.setTextAlignment(Qt.AlignCenter) 
            self.dockwidget.tableParam.setItem(i,1,label2)

            label3.setText(str(self.param_range[k][1])) 
            label3.setTextAlignment(Qt.AlignCenter) 
            self.dockwidget.tableParam.setItem(i,2,label3)

            flags = Qt.ItemFlags()
            flags != Qt.ItemIsEditable
            label4.setText(str('nan'))
            label4.setBackground(QColor(50,50,70))
            label4.setFlags(flags)
            self.dockwidget.tableParam.setItem(i,3,label4)
            label4.setTextAlignment(Qt.AlignCenter)

            check.setCheckState(False);
            #check.setAlignment(Qt.AlignCenter) 
            self.dockwidget.tableParam.setItem(i,4,check)


        self.dockwidget.tableParam.setVerticalHeaderLabels(row_name)


    def sample_prosail(self):
        prosail_wavelength = np.arange(400,2501,1)
        centers = np.array([442.7,492.4,559.8,664.6,704.1,740.5,782.8,832.8,864.7,945.1,1373.5,1613.7,2202.4]) 
        centers = centers[used]
        centers_idx = []
        for x in prosail_wavelength:
            centers_idx.append(x in centers.astype(np.int))

        angles = self.get_angles_S2()
        #rsot = self.calc_prosail(self.param_current)
        #relative_spectra=rsot*self.sensi.T
        #bands = np.nansum(relative_spectra,axis=1).T
        #self.rsot_plot.set_ydata(rsot)
        #self.bands_plot.set_ydata(bands[used])
  
        for i in range(len(self.all_plot)):
            item = self.all_plot.pop(-1)
            item.remove()

        #self.text_param.remove()
        #param_text = "Calculating"
        #self.text_param = plt.text(2250,0.01,param_text)
        #self.figure.canvas.draw()
        #print("Start")

        self.n_LUT = self.dockwidget.spinBoxnLUT.value()

        if(True):
            print("DEBUG: Start sampling")
            samples = np.zeros((8,self.n_LUT))
            for i,k in enumerate(self.param_range.copy().keys()):
                if self.dockwidget.tableParam.item(i,4).checkState() == 0:
                    sample = np.random.uniform(self.param_range[k][0],self.param_range[k][1],self.n_LUT)
                else:
                    sample = np.random.uniform(self.param_current[k][0],self.param_current[k][0],self.n_LUT)
                samples[i] = sample

            samples[2] = samples[2] + samples[0]*0.004
            #inparams=inparams[:,np.squeeze(np.greater(inparams[2,:],0))]
            
            self.inparam = samples
            print("DEBUG: End sampling, Start prosail")
            bands_list = []
            for inparam in samples.T:
                rsot = self.calc_prosail(inparam,angles)
                relative_spectra=rsot*self.sensi.T
                bands = (np.nansum(relative_spectra,axis=1).T)
                bands_list.append(bands)

            self.Var_sim = np.stack(tuple(bands_list))[:,used]
            bands_mean = np.mean(self.Var_sim,axis=0)
            bands_std  = np.std(self.Var_sim,axis=0)

            if self.iteration_prior:
                plabel = "_nolegend_"
            else:
                plabel = "Prior (avg/std)"
                self.iteration_prior = True

            print("DEBUG: End prosail. Start Plot")
            colors_list = plt.cm.plasma(np.linspace(0,1,self.n_LUT))
            for i,b in enumerate(self.Var_sim):
                    p, = self.ax1.plot(centers,b,color = 'k',alpha = 0.01)
                    self.all_plot.append(p)

            p  = self.ax1.errorbar(centers,bands_mean,yerr=quantile*bands_std,color = 'b', label = plabel)
            self.all_plot.append(p)

            self.ax1.set_title("(n_LUT = %d)"%(self.n_LUT))
            print("DEBUG: End Plot")

          
            #self.text_param.remove()
            #param_text = ""
            #for k in self.param_current.keys():
            #    param_text = param_text + "%s: %.2f\n"%(k,self.param_current[k])

            #self.text_param = plt.text(2250,0.01,param_text)
            self.figure.legend()
            self.figure.canvas.draw()
            print("Stop")



            self.ax1.set_xlim(prosail_wavelength[0],prosail_wavelength[-1])
            self.ax1.set_ylim(0,1)


    def table_change(self):

        for r in range(self.dockwidget.tableParam.rowCount()):
            k = self.dockwidget.tableParam.verticalHeaderItem(r).text()
            pmin = float(self.dockwidget.tableParam.item(r,0).text())
            pval = float(self.dockwidget.tableParam.item(r,1).text())
            pmax = float(self.dockwidget.tableParam.item(r,2).text())
            self.param_current[k] = [pval,(pmax-pmin)]
            self.param_range[k] = [pmin,pmax]
        print(self.param_current)

    #def erase_button_clicked(self):
    #    for i in range(len(self.all_plot)):
    #        item = self.all_plot.pop(-1)
    #        item.remove()
    #    self.figure.canvas.draw()

    #def all_button_clicked(self):
    #    print(self.dockwidget.checkSpan.value)
    #    pass
      
    def Coordinates(self,data_provider,point):
        extent = data_provider.extent()
        width = data_provider.xSize() if data_provider.capabilities() & data_provider.Size else 1000
        height = data_provider.ySize() if data_provider.capabilities() & data_provider.Size else 1000
        xres = extent.width() / width
        yres = extent.height() / height

        if extent.xMinimum() <= point.x() <= extent.xMaximum() and \
            extent.yMinimum() <= point.y() <= extent.yMaximum():
            col = int(floor((point.x() - extent.xMinimum()) / xres))
            row = int(floor((extent.yMaximum() - point.y()) / yres))
        else:
            col = -1
            row = -1

        X = point.x()
        Y = point.y()

        return X,Y,col,row


    def get_bands(self,data_provider,point):
        nband = data_provider.bandCount()
        val = []
        for i in range(nband):
            v,res = data_provider.sample(point,i+1)
            val.append(v)
        val = np.array(val)
        return nband,val

    def get_angles_S2(self):
        #gets all observation and solar angels for sENTINEL2
        xml_path = self.dockwidget.xmlpath.filePath() 
        doc = minidom.parse(xml_path)
        angles={}
        angles["solar_zen"]   = np.double(doc.getElementsByTagName('ZENITH_ANGLE')[0].firstChild.data)
        angles["solar_azi"]   = np.double(doc.getElementsByTagName('AZIMUTH_ANGLE')[0].firstChild.data)
        angles["obs_zen"]   = np.double(doc.getElementsByTagName('ZENITH_ANGLE')[4].firstChild.data)
        angles["obs_azi"]   = np.double(doc.getElementsByTagName('AZIMUTH_ANGLE')[4].firstChild.data)
        return angles
        
    def normal(self,x,mu,sig):
        return(1.0/(np.sqrt(2.0*np.pi*sig*sig))*np.exp(-(x-mu)*(x-mu)/(2.0*sig*sig))) 
        
    def update_dist_plot(self):
        k1 = self.dockwidget.combo_param.currentText()
        idx1 = self.dockwidget.combo_param.currentIndex()
        k2 = self.dockwidget.combo_param2.currentText()
        idx2 = self.dockwidget.combo_param2.currentIndex()
        binsize = self.dockwidget.spinBoxBinSize.value()
        self.ax2.cla()
        
        post_param_mean = np.sum(self.inparam[idx1]*self.likelyhood.flatten(),axis=0)/np.sum(self.likelyhood.flatten(),axis=0)
        post_param_std  = np.sqrt(np.sum(self.likelyhood.flatten()*(self.inparam[idx1]-post_param_mean)**2,axis=0)/np.sum(self.likelyhood.flatten(),axis=0))
        if not self.dockwidget.checkBox_2d.isChecked():
            self.ax2.hist(self.inparam[idx1],color='r',alpha=0.3,density=True,bins=np.linspace(self.param_range[k1][0],self.param_range[k1][1],binsize))
            self.ax2.hist(self.inparam[idx1],color='b',alpha=0.3,weights=self.likelyhood.flatten(),density=True,bins=np.linspace(self.param_range[k1][0],self.param_range[k1][1],binsize))
            self.ax2.set_title(k1)
            self.ax2.set_xlabel(k1)
            self.ax2.set_ylabel("P(%s)"%(k1))
            x=np.linspace(self.ax2.get_xlim()[0],self.ax2.get_xlim()[1],100)
            self.ax2.plot(x,self.normal(x,post_param_mean,post_param_std),color=[0.2,0.7,0.3])
            self.ax2.plot([post_param_mean,post_param_mean],[0,self.normal(post_param_mean,post_param_mean,post_param_std)],color=[0.2,0.7,0.3])
            self.ax2.plot([post_param_mean+post_param_std,post_param_mean+post_param_std],[0,self.normal(post_param_mean+post_param_std,post_param_mean,post_param_std)],color=[0.2,0.7,0.3])
            self.ax2.plot([post_param_mean-post_param_std,post_param_mean-post_param_std],[0,self.normal(post_param_mean-post_param_std,post_param_mean,post_param_std)],color=[0.2,0.7,0.3])
        else:
            bin2d = [np.linspace(self.param_range[k1][0],self.param_range[k1][1],binsize),np.linspace(self.param_range[k2][0],self.param_range[k2][1],binsize)]
            self.ax2.hist2d(self.inparam[idx1],self.inparam[idx2], bins=bin2d, density=True, weights=self.likelyhood.flatten())
            self.ax2.set_title("%s - %s"%(k1,k2))
            self.ax2.set_xlabel(k1)
            self.ax2.set_ylabel(k2)
        self.figure.canvas.draw()
 

    def clickedOnMap(self, point, button):

        for i in range(len(self.posterior_plot)):
            item = self.posterior_plot.pop(-1)
            item.remove()

        # Getting appropritate layers
        raster_layer = self.iface.activeLayer()
        print(raster_layer.name())
        #raster_name = self.dockwidget.comboBox_raster.currentText()
        #raster_layer  =  QgsProject.instance().mapLayersByName(raster_name)[0]

        # Getting raster info
        data_provider_raster = raster_layer.dataProvider()

        # Manage canvas coordinate
        X1,Y1,col1,row1 = self.Coordinates(data_provider_raster,point)

        # Getting pixel dat
        nband_raster, profile_raster = self.get_bands(data_provider_raster,point)

        # Specific management
        print(profile_raster)


        print("DEBUG: Start Likelyhood")
        init_loglikelyhood = np.zeros((self.n_LUT,1))
        Var_obs = profile_raster.reshape((1,len(profile_raster)))
        Var_obsstd = 0.04*np.ones((1,len(profile_raster)))
        Var_sim = self.Var_sim 
        #Var_sim = np.random.rand(N_LUT,N_DATES) # OK
        #Var_obs = np.random.rand(N_OBS,N_DATES) # OK
        #Var_obsstd = np.random.rand(N_OBS,N_DATES) # OK
        self.likelyhood = self.likelyhood_SAFY_new_nan(init_loglikelyhood,Var_sim,Var_obs,Var_obsstd)
        print("DEBUG: End Likelyhood")

        centers = np.array([442.7,492.4,559.8,664.6,704.1,740.5,782.8,832.8,864.7,945.1,1373.5,1613.7,2202.4])
        centers = centers[used]
        likelyhood_alpha = 0.05*self.likelyhood.T.flatten()/np.max(self.likelyhood)
        print("HERE",likelyhood_alpha.shape,Var_sim.shape,self.likelyhood.shape)
        for i,b in enumerate(Var_sim):
            p, = self.ax1.plot(centers,b,color = 'r',alpha = likelyhood_alpha[i])
            self.posterior_plot.append(p)
 
        print("sum ",np.sum(self.likelyhood))
        bands_mean_posterior = np.sum(Var_sim*self.likelyhood,axis=0)/np.sum(self.likelyhood,axis=0)
        bands_std_posterior =  np.sqrt(np.sum(self.likelyhood*(Var_sim-bands_mean_posterior)**2,axis=0)/np.sum(self.likelyhood,axis=0))

        if self.iteration_posterior:
            qlabel = "_nolegend_"
        else:
            qlabel = "Posterior (avg/std)"
            self.iteration_posterior = True

        p  = self.ax1.errorbar(centers,bands_mean_posterior,yerr=quantile*bands_std_posterior,color = 'r', label = qlabel)
        self.posterior_plot.append(p)

        self.s2_plot.set_ydata(profile_raster)

        for i,ip in enumerate(self.inparam):
            post_param_mean = np.sum(ip*self.likelyhood.flatten(),axis=0)/np.sum(self.likelyhood.flatten(),axis=0)
            post_param_std  = np.sqrt(np.sum(self.likelyhood.flatten()*(ip-post_param_mean)**2,axis=0)/np.sum(self.likelyhood.flatten(),axis=0))
            #print("DEBUG ",post_param_mean.shape,post_param_std.shape)
            txt = "(%.2f,%.2f)"%(post_param_mean,post_param_std)
            # ("(%.2f,%.2f)"%(post_param_mean,post_param_std))
            self.dockwidget.tableParam.item(i,3).setText(txt)

        self.update_dist_plot()
 
        self.figure.canvas.draw()
    
    def pick(self):
        self.emitPoint = QgsMapToolEmitPoint(self.canvas)
        self.canvas.setMapTool(self.emitPoint)
        self.emitPoint.canvasClicked.connect(self.clickedOnMap)


    def saveSettings(self):
        with open(self.plugin_dir + "/settings.txt","w") as f:
            #f.write(str(self.dockwidget.comboBox_N0.currentIndex())+"\n")
            #     f.write(str(self.dockwidget.comboBox_N1.currentIndex())+"\n")
            #     f.write(str(self.dockwidget.comboBox_raster.currentIndex())+"\n")
            f.write(self.dockwidget.xmlpath.filePath())


    #--------------------------------------------------------------------------
    def initialization(self):
        self.iteration_prior = False
        self.iteration_posterior = False
       # Get settings file parameter
        
       # #l0 = 0
       # #l1 = 1
       # #l2 = 2
        runpath = ""
        with open(self.plugin_dir + "/settings.txt","r") as f:
            try:
                #l0 = int(f.readline())
                xmlpath = f.readline().strip()
            except:
                pass

       # # Declare parameter widgets

        self.dockwidget.xmlpath.setFilePath(xmlpath)

        # Init combo box
        self.param_list = ["lai","lidfa","cm","cab","n","car","psoil","soil type"]
        self.dockwidget.combo_param.clear()
        self.dockwidget.combo_param.addItems(self.param_list)
        self.dockwidget.combo_param.currentIndexChanged.connect(self.combo_change)
        self.param = self.dockwidget.combo_param.currentText()
        self.n_LUT = 5000
        self.dockwidget.combo_param2.clear()
        self.dockwidget.combo_param2.addItems(self.param_list)
        self.dockwidget.combo_param2.currentIndexChanged.connect(self.combo_change)
        self.param = self.dockwidget.combo_param2.currentText()

        #self.param = self.dockwidget.combo_param_all.currentText()

        #self.dockwidget.pickmap.clicked.connect(self.pick)

        # Init file path
        #self.dockwidget.runpath.setStorageMode(1)

        # Init plot area
        self.figure = plt.figure(figsize = (10,3))
 

        #plt.ylabel('a posteriori \n'+self.varname_sim,fontsize=10)
        #plt.xlabel('date',fontsize=10)
        #self.plots = []
        #p, = plt.plot([0,1],[0,1], color = 'g') # NOTE: becarefull with the syntax. there is a comma.
        #self.plots.append(p)
        
        self.scene = QGraphicsScene(self.dockwidget)
        window = FigureCanvas(self.figure)
        self.scene.addWidget(window)
        self.dockwidget.graphicsView.setScene(self.scene)
        self.dockwidget.show()
 
        self.figure.canvas.draw()

        # Init prosail
        prosail_wavelength = np.arange(400,2501,1)
        sensi = np.loadtxt(self.plugin_dir + '/data/sensi_S2_400_2501.txt', delimiter="\t")
        self.sensi = (sensi/np.sum(sensi,axis=0))[:,1:]

        centers = np.array([442.7,492.4,559.8,664.6,704.1,740.5,782.8,832.8,864.7,945.1,1373.5,1613.7,2202.4])
        centers = centers[used]

        self.scaled_soil_dic = {}
        for i in range(10):
            soil_spectrum = self.plugin_dir + "/data/optical_properties_soil%02d.txt"%(i+1)
            soil_spec=np.loadtxt(soil_spectrum, delimiter=" ")
            scaled_soil=np.interp(prosail_wavelength,soil_spec[:,0],soil_spec[:,1])/100
            self.scaled_soil_dic[i+1] = scaled_soil 

        self.param_range = {}
        self.param_range["lai"]       = [0,7]
        self.param_range["lidfa"]     = [45,65]
        self.param_range["cm"]        = [-0.02,0.02]
        self.param_range["cab"]       = [40,80]
        self.param_range["n"]         = [1,2]
        self.param_range["car"]       = [5,20]
        self.param_range["psoil"]     = [0,1]
        self.param_range["soil type"] = [1,10]

        self.param_current = {}
        for k in self.param_range.keys():
            mu    = (self.param_range[k][1]+self.param_range[k][0])/2.0
            sigma = (self.param_range[k][1]-self.param_range[k][0])

            self.param_current[k] = [mu,sigma]

        #self.dockwidget.Slider_param_mean.setRange(self.param_range[self.param][0],self.param_range[self.param][0])
        #self.dockwidget.Slider_param_mean.setValue(self.param_current[self.param])

        #self.dockwidget.Slider_param_mean.setTickPosition(QtWidgets.QSlider.TicksBelow)
        #self.dockwidget.Slider_param_mean.setSingleStep(1)
 
        self.ax1 = plt.subplot(121)
        self.all_plot = []
        self.posterior_plot = []
        p, = self.ax1.plot(prosail_wavelength,0*prosail_wavelength,"b")
        self.all_plot.append(p)
        q, = self.ax1.plot(prosail_wavelength,0*prosail_wavelength,"b")
        self.posterior_plot.append(q)
        #self.rsot_plot,  = ax1.plot(prosail_wavelength,0*prosail_wavelength,c = 'k',ls='dashed',zorder=21,label= "simulated spectrum")
        self.sensi_plot, = self.ax1.plot(prosail_wavelength,0*prosail_wavelength, c = 'k', alpha = 0.2)
        #self.bands_plot, = ax1.plot(centers,0.0*centers,'r+' ,label = "Posterior")
        self.s2_plot,    = self.ax1.plot(centers,0.0*centers,'gx' ,zorder=21,label = "S2 obs.")
        self.ax1.set_xlim(prosail_wavelength[0],prosail_wavelength[-1])
        self.ax1.set_ylim(0,1)
 

        self.ax2 = plt.subplot(122)

        self.figure.tight_layout()
        
        #self.text_param = plt.text(2250,0.01,"#Init Param#")
        
       

        #self.dockwidget.Slider_param.setFocusPolicy(Qt.NoFocus)
        #self.dockwidget.Slider_param_mean.setPageStep(1)
        #self.dockwidget.Slider_param_std.setPageStep(1)

        #self.dockwidget.Slider_param_mean.sliderMoved.connect(self.slider_change)
        #self.dockwidget.Slider_param_std.sliderMoved.connect(self.slider_change)
        self.dockwidget.xmlpath.fileChanged.connect(self.saveSettings)
        self.dockwidget.pickmap.clicked.connect(self.pick)
        self.dockwidget.sampleButton.clicked.connect(self.sample_prosail)

        self.dockwidget.checkBox_2d.stateChanged.connect(self.update_dist_plot)
        self.dockwidget.spinBoxBinSize.valueChanged.connect(self.update_dist_plot)

        self.update_table()
        self.dockwidget.tableParam.itemChanged.connect(self.table_change)

        self.pick()



    def run(self):
        """Run method that loads and stazenith_sunrts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING ProsailPlugin"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = ProsailPluginDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock sliderMoved()location
            self.iface.addDockWidget(Qt.TopDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
            self.canvas = self.iface.mapCanvas()
            self.initialization()
